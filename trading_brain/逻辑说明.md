# Trading Brain 逻辑说明

## 📅 日期设置

### 主数据包日期（第324行）

```python
"date": datetime.now().strftime("%Y-%m-%d")
```

**说明**:
- 使用**当前系统日期**（运行脚本时的日期）
- 格式: `YYYY-MM-DD`
- **不依赖数据源日期**，始终是运行时的日期

**示例**: 如果今天是 2025-12-06，则 `date = "2025-12-06"`

---

## 📊 第一层级时间设置

### FRED API 数据

| 指标 | 查询范围 | 代码位置 | 说明 |
|-----|---------|---------|------|
| **WALCL, TGA, RRP** | 30天前 → 今天 | 第68-69行 | 周频数据，30天足够 |
| **DGS2, T10Y2Y** | 60天前 → 今天 | 第141-142行 | 日频数据，60天确保有数据 |

**数据提取**: 取数组最后一个值 `data[-1]`（最新值）

### yfinance 数据

| 指标 | 查询范围 | 代码位置 | 说明 |
|-----|---------|---------|------|
| **DXY, US10Y, SPX, NDX, CNY** | 3个月前 → 今天 | 第105行等 | `period="3mo"`，避免周末数据缺失 |

**数据提取**: 取数组最后一个值 `data[-1]`（最新值）

---

## 📊 第二层级时间设置

| 数据 | 时间范围 | 说明 |
|-----|---------|------|
| **Stablecoin Market Cap** | 实时（当前值） | 无历史查询 |
| **ETF Net Inflow** | T+1（昨天） | Farside网页，获取最新一行 |

**注意**: ETF数据是T+1的，今天运行获取的是昨天的数据

---

## 📊 第三、四层级时间设置

| 数据 | 时间范围 | 说明 |
|-----|---------|------|
| **BTC Dominance, ETH/BTC Ratio** | 实时（当前值） | CoinGecko API |
| **Funding Rate, OI, 多空比** | 实时（当前值） | Binance API |
| **Fear & Greed Index** | 每日更新 | Alternative.me |

---

## 🔍 数据填充策略

### ❌ 当前实现：无填充

**如果数据获取失败**:
- FRED数据失败 → `indicators` 字典中不包含该指标
- yfinance数据失败 → 跳过，不保存
- Crypto数据失败 → 返回 `None` 或空字典

**示例**:
```json
{
  "indicators": {
    "dxy": {"value": 102.5},  // ✅ 成功
    // "us10y": 缺失          // ❌ 失败，不填充
  },
  "layer4_sentiment": {
    "price_btc": null,        // ❌ 失败，值为null
    "fear_greed_index": 23    // ✅ 成功
  }
}
```

---

## 🕐 时间对齐问题

### 不同数据源的时间差异

| 数据源 | 实际数据日期 | 示例 |
|--------|------------|------|
| FRED (WALCL) | 可能延迟3-7天 | 2025-11-29 |
| yfinance (DXY) | 实时（今天） | 2025-12-06 |
| ETF数据 | T+1（昨天） | 2025-12-05 |
| Binance数据 | 实时（现在） | 2025-12-06 16:06 |

### 当前处理方式

**不进行时间对齐**:
- 每个指标使用各自的最新可用值
- 接受时间差异（这是正常的）
- 不强制要求所有数据都是同一天的

---

## 📋 关键代码位置

### 日期设置

```python
# 主数据包日期
第324行: "date": datetime.now().strftime("%Y-%m-%d")

# FRED查询范围
第68-69行: start_date = (datetime.now() - timedelta(days=30))
第141-142行: start_date = (datetime.now() - timedelta(days=60))

# yfinance查询范围
第105行等: period = "3mo"
```

### 数据提取

```python
# 获取最新值
第84-86行: latest = data["data"][-1]  # 数组最后一个
value = latest.get("value")
```

### 数据保存

```python
# 保存到indicators
第90-97行: layer1["indicators"]["fed_net_liquidity"] = {...}
```

---

## 💡 总结

### 日期设置总结

1. **主数据包日期**: 使用当前系统日期（运行时的日期）
2. **Layer1 - FRED**: 查询30-60天范围，取最新值
3. **Layer1 - yfinance**: 查询3个月范围，取最新值
4. **Layer2-4**: 实时数据，无历史查询

### 数据填充

- ❌ **当前**: 无填充，失败的数据保持为空或None
- ✅ **优点**: 数据真实，不会误导
- ⚠️ **缺点**: 部分数据缺失时，信号可能不完整

### 时间对齐

- ❌ **当前**: 不进行时间对齐
- ✅ **原因**: 不同数据源本身就有时间差异
- ⚠️ **注意**: 使用时要注意数据的时间戳

